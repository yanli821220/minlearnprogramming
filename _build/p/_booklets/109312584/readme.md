---
layout: page
include_in_header: false
permalink: /_booklets/109312584/
---
一种云化busybox demolets的设想和一种根本降低编程实践难度的设想:免部署无语法编程
=====

__本文关键字：shell language,debuginbuilt+google oriented programming practise+drive。programming:dgv programming，限制源码规模。，Debug appliance inbuilt__

在《软件即抽象》中我们讲到编程的本质是用抽象来构建图灵完备的概念体系，语言本身提供有限抽象，还负责映射无限的问题域抽象到有限的平台抽象域（各种语言在平台已实现了的lib,runtime,api,binary interface可开发件,对于云，只有api/api stub,无平台依赖），然而当代编程还停留在传统阶段，其过程和方法，依然是编码和调试以及维护，这导致了现在的编程依然很原始：

1，来说点抽象和科学层面的，由于组成编程的抽象本身是巨大的，同时要整合进语言平台问题和设计，所以编程复杂性始终无法脱离对其对那个工程规模级别知识库的东西进行背书，虽然编程语言编程工具和各种中间件越来越抽象，极大谈化了一部分抽象，编译器作为语言实现，虽然有宽松的repl和越来越强大的各种动态语言能力和运行时设施解放编译期检查，但始终只接受那些编译通过了的每一条语言元素。虽然有标准化但编程的软硬平台生态一向很破碎各自为政变动频繁这导致其附属开发也破碎，而且编程中很多部件和高层概念依赖很专业的东西构建，这些依然无法做到彻底抛弃和替换，使得人们难入阶即使入阶后依然不能举一反三（提供工具级和外来辅助手段降低编程入阶的专业度难度只能做到有限的效果。如果仅仅这样，后面遇到的曲线照样会陡峭。并没有越过曲线就一马平穿的道理，抽象依然存在）。

2，来说点具体和艺术层面的，对于具体实践中的编程编码和调试的难度也来自于组成编程各部件的固有复杂性，调试是驱动编程循环的，但语言基于数学和形式理论和图灵完备结果，平台最终是冯氏的内存加指令（大部分调试需要进入内存反工程，这影响我们不可能在一个更高的阶层上调试），平台加APP加语言运行时构成的那个内存中的巨大复杂运行时的追踪，从问题域映射到方案域一条路径上的所有细节，从搭建环境开始这条路径从开始到能看到结果很长，才能完成一次调试编码循环（devops正是为了解决这类问题，使得部分前置调试过程自动化，使得能看到结果的路径超短,不过这也是权宜。），足于把普通水平和没有耐心的人排除在外。

> 编程文科属性还是理科属性强一点？答案显然是后者，虽然编程语言有词法，语法，有点像作文，但实际上，跨过这些文法属性，属于理科的实验部分的属性还是比较强占比比较大，在编程中，需要不断调试，设立各种调试环境，追踪各种结果，验证想法。编程看来起像跟编译器对话，但是这跟自然语言完全不是一个级别(但是有一个例外：对于同一种抽象也存在多种表达法，类似文科中的写作文，每个人用于实现的中间过程都不相同，即抽象的多义性，但这反而正是工业编程中极力要避免的)，实践的10000小时理论+"无它唯手熟尔"对于编程来说不是十分适用因为我们往往把时间浪费在重复的事情上。往往对于一门语言，学了很久的语言高级技法，说了这么久，那么高级语法可能你用不着，实践中主要碰到解决的还是几大流程结构的熟练度问题。我们有时甚至要跟{}是否配对大战一天一夜。

------ 换言之编程的专业度和难度还是十分巨大，一直到现在，我们都没从根本上改变编程的形式和本质，只是不断变换抽象和堆叠抽象。所以出现了各种其它从不堆积抽象的传路路子，试图另找出路从根本上降低编程难度的创新方法，我们一一道来。

一些旧路子,及一种云化busybox demolets的设想
-----

在全面降低编程复杂度方面，在语言级有很多我们耳熟能详的编程流派和学说(模块化，OO，etc..)。它们只是修补解决了一部分问题，比如对于敏捷方法论：，现在的编程基础如此，“一次设计”要完成的事情要把握的抽象幅度依然很多很大更别说往后的生命期内维护，对于最基本的模块化：编程是否真的可以像堆积木那么容易。但这或许正加大了复杂度，如果说任何一个小程序都需要大量逻辑的组合，那么人类始终只有一个限制：不能一次把握的大量的规模，接口，完成一次设计，这是一对似乎不能解决的矛盾。。devopsp这类手段其实其作用并不是级极的，它属于普遍的一种降低入阶和中间层的方法，上面说到，要做到降低整个编程难度，也并非上述降低入口难度这么简单。。编程所有的问题的复杂性是来自它的规模本来就是工程级别的。。。于是人们说在形成现在编程的所有基础和编程体制中“软件无银弹”。这依旧是文章一开始提到的编程复杂固有度问题。

然后就是那些高于语言级别的：

旧一点的有visual programming+rad，trigger editor,面向搜索引擎的编程，敏捷方法，serverless编程(这只是在devops减轻了环境搭建)，面向二进制编程(这类似基于接口的源码/业务逻辑抛弃型编程)，我也提出过一些方法，如《一种shell programming的设想》。《engitor:demo+debug driven programming》。甚至有基于程序员的契约编程（还记得py排版空格规则都是强制的么） ，

> 我们对于编程实践的讨论和降低其难度的尝试在很多地方都涉及过，如《xaas,appstack及综合实践选型通史》，和《兼谈fuchsia:一种快速编程教学系统和rust编程语言快速学习项目》，以及上面谈到的二文，我们可以将上面所有旧的路子结合起来：打造一种分布式busybox和一组云化cli demolet based programming设想：bash等shell语言可以说是busybox的专用语言，它组成了cli shell tools的可“编程”环境（可调用环境更准确一点），使得运维人员和非专业人员可以以简单的命令组合搭建shell脚本程序，完成较gui环境下更自由更强大的console应用任务。其本质是类似一种在内可脚本写作的可视化编辑器环境,如游戏世界编辑器（只不过不用trigger editor，而单纯用脚本,业务逻辑已写好并提供为cli）。在《一种shell programming式编程》中我们讲到，这是一种开发与问题合一的环境，于是这里的效果几乎结合了上面“可视化，demobasedprogramming,二进制脱离业务实现级别的编程”三种效果了。而采用的bash是一种真正的非专业人员定制语言，真正的非专业人员就要使用这种去除了严肃语言特色的东西。bash甚至没有模块。但这正是它的优点，因为这对于那个调试，还可以像shell一样基于pipe based调试而不是传统语言statement和module based的单元调试。每一句返回状态才能继续，这样调试方便。前后无语义联系。一句一写的程序，而不是预先写成为单元。bash无模块也做到了控制逻辑的最终规模大小的问题（当然在bash+demolet programming这个层次上是不追求复用的，由于这个层次跟编写业务逻辑的严肃编程层断出了新的层面，因此它去掉了传统编程的难度和抽象规模固有问题）。

> 这里重点谈下面向接口，面向接口编程非OO语言用来实现多继承的interface关键字用于避免基于类的多继承缺陷的那一套，它更偏向指面向二进制的编程（面向组件编程面向构件编程面向积木编程），它允许业务逻辑（实现部分）与脚本逻辑分开（隔离并“抛弃”实现部分的源码，建立abi stub封装为大量二进制接口，接口专门可在另一级别被以“已部署”编程，新提出一个可编程层次，这个层次可以”无传统语法“进行，极大简化编程难度，比如允许bash轻语法语言+html标记语言这类用户级编程发生），建立接口的过程可以用类似busybox的方法批量生成。也可以是来自toolchain的一种自动支持。按二进制接口导出,最后的效果是你在类似c# ide中能实现直接查看dll透出的服务的效果。它一度被称为软件银弹真正解决法后来被脚本"源码as组件"和“面向服务,soa”这类东西模糊化。

本书第二大部分《minstack os : openaas+vscode os : debugable appliance builtin os for dever and common user》也正是为了提出一种这样的抹掉中间层复杂性的努力(它是一个三层结构：1，terralang + vscodeonline + openfaas cliiz backend, 2, distribute busybox tools,3, bash+apps+businesslogic languages+ more businesslogic demolets)，并没有提出彻底的解决之法，开头就说了它只是一种降阶法并没有解决抽象规模过大的固有问题，只是现阶段它可能会工作良好，所以我们叫它暂代方案。

未来我们依然需要包括上述方案在内的其它寻求全面降低编程复杂度以降低实践复杂度的方法

一些新路子：终极AI辅助和轻理科属性编程,literate+natureprogramming
-----

新点的有：如ai辅助编程，，codeless无代码编程，literate programming（注意我不是指现在的基于xml和描述性语言的文学编程。）,这些是区别于上面不能降低编程固有复杂度的根本性创新方法。因为它不能解决了改变传统编程中二大对象人和机的根本定位，这个努力的方向只能是AI,是一开始就是人跟人之间那种智能理解辅助级别的，比如，将编程语言的形式理论根本，发展为真正自然语言识别层次。或者提供一个智能机器人，其智能能达到和你结对编程辅导的地步。

那么，编程，能否真的有一天，能达到人人对话这个级别，彻底走过人机人编译器对话的原始阶段呢？大约等到共享汽车真的能做到在人挤人的街道上正常工作的时候，这个梦想就能有实现了(我是不太相信智能汽车的，智能有些东西在任何学科包括哲学上都处在没被解决的阶段)。


-------


(此处不设回复，扫码到微信参与留言，或直接点击到原文)

![](/p/109312584/qrcode.png)

<!-- Markdeep: -->
<meta charset="utf-8">
<link rel="stylesheet" href="../../res/aloha.css?">

<script src="../../res/markdeep.min.js" charset="utf-8"></script>

