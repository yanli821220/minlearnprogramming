---
layout: page
include_in_header: false
permalink: /_booklets/106344717/
---
一种开发发布合一，语言问题合一的shell programming式应用开发设想
=====

__本文关键字：最简单的编程模式,具体app具体开发,将开发局限在具体app级,demo as engine__

在我们前面，为了ease编程复杂度和去断层化，我们从xaas聊到langsys,devops tools,domainstack，涵盖众多，我们提到云化程序应该与云容器一起考虑，开发与部署一体，才能可能达到更自然的类本地API导出+api sync的分布式，我们还提到很多语言，比如terralang，还提到很多devops tools,我们其实都有一个错觉，以为编程的复杂性来自于语言，系统，这实际是对的，可又有失全面限制我们的认识面。—— 因我们始终没有考虑进对问题的理解，因为编程即抽象，是涉及语言，平台，问题，人全面四者的,平常我们总是把它们当成是语言的附属 —— 一些库级的语言附属品，问题总是被抽象成某语言的可复用库，业界从来都没有关于它的独立考量和成套的技术，但实际上跳出这些，做综合全观，往往会有意想不到的认识，比如我们发现： —— 具体问题域可以与具体app绑定。而app级，可以有具体语言绑定，作开发发布。而这是一种更为正宗的“应用编程”，有完整的xaas,langsys,app,people的生态，而且更强大。

较之目前，xaas,langsys这类基础工具往往做得不够亲和，它们对抬高编程入阶的影响也就越大的现实。。如果把这种开发独立出来成为一支，使之主动无缝对接前二者。另辟新径，整个编程会显得尤为更简单,比如，它免部署，甚至不需要用到通用语言这种难懂的东西。

这篇文章将综合描述这种可行的案例。

为什么shell programming是最简单强大的programming
-----

在我们使用os的最初，我们使用C系作应用开发，同时作为一个开发者，自己还敲打一些命令行，进行一些运维级的操作和浅层shell开发。CUI和GUI的使用分开了运维和普通使用者。shell编程用类似配置的方法提出了第一种编程方式 —— 这些都是我们现在经常做的事。可是稍微一想就会觉得很分裂：为什么C语言用指针file* 来抽象文件，CPP可以用FILE file，它们抽象编程的方法都用了与它们的简元，语句这些直接的基础设施，而shell可以直接操作一个文件，不用类型指代，这源于一个傻子都明白的事实：任何编程，只要它的代码是要存为目标上的可执行文件的，编程都是为运行期作预编码的事实。在编程的时候，运行期是未知的，除非debug的时候，或devops调用模拟器的时候，这就造成了编程的脱节。

而shell编程恰恰相反，编程是在现在的上下文中作运维。开发和部署是天然一体的。而且最重要的，问题和要编码的事，都是天然一体的。

>编程最难也是最难统一的：
>第一是开发和发布的断层，它使开发可以依赖通用语言，而不是发布上下文相关的语言。这带来了强大性，但也使人们分裂，因为通用语言必须用最原始的机制先后去抽象平台，人，最后才到目标问题和目标appstack。难度徒增。
在分布式程序中，这种难度尤甚。
>第二，无非是对问题域的抽象。就像VB，抽象了界面开发为触发/触发处理。VB的做法向现实生活抽象，但是对于其它域，它就没有抽象的可能。线程能抽象并发，但也仅此而已。没有一种抽象习惯用法能统管所有，还很好用。设计模式也不能。

较shell programming，用传统方法作应用编程，没有直接一行代码如shell programming所做到的那样，一行代码敲下去，就能立马出效果的东西存在。但这极有可能是我们需要的最终唯一的东西 — 因为任何程序都会是一种执行体。我们只需“具体APP在具体OS下只须具体开发”

这是因为，我们业界，应用层编程始终还在用着实现层的东西。而且我们一遍遍用这种方法来解决我们的上上层开发。而且一直天真地以为：程序必须要预先编制，先编写好，后运行。——  而busybox规范下的，系统和系统shell编程的本质，就是一对天然可以融合的东西，是任何系统应用编程的所有。自成生态的所有。独立，闭环，好用。

但是，千W不要以为shell编程就很简单，它不能称为通用语言和通用开发，是因为它仅仅不那么做，高级shell编程只限于运维，不像系统开发者，涉及到对内存的使用（有指针，etc..）产出系统程序，但高级shell编程的复杂度往往不比py这类脚本语言低，其语句，类型也颇为接近一般语言。—— 它的强大是因为它足够自我。

而且，它可用于任何编程。准确来说。任何系统应用编程，都可以是这种shell编程。

任何APP编程都是shell programming
-----

想象一下，比如要开发一个这样的普通应用和准备一套这样的langsys：最终的这个程序，应该是一个类busybox这类可裁剪的的exe系统，demo as engine,搭配一个bash，就能写batch调用，bat调用即app，busybox就相当于一个函数库，里面的各个exe其实汇总起来组成了一个模块，只不过语言本身也是这个exe之一，app即exe的调用。函数即exe，参数即io，再也不用理解py那些理念懂基本的C系流程即可，开发上，直接用OS的观点来对应语言简元。比如，类似9P，任何一个语言元素都可以形成为fs的一个对象，everythingis a file,the programmingdomain programming is about file io。

其本质，就是把语言抽象的机制与OS系统应用的机制（包括语言，当时执行的上下文，这就需要一个容器保存）结合起来。这样，计算机应用直接对应开发。编程即计算机应用。编程即系统功能配置。以及问题操作，开发即运维。

上面所涉及到的要素，重点介绍以下：应用即容器。exe is componet,os is container。

1，它与容器搭配使用。

套间，接口，这不就是组件的那些概念么，可是传统组件没有os container保存不了部署上下文和运行期的那些资源，只有部署包含了，那么就能称为demo,否则只是一个执行体。这种APP是一个容器镜像，在展开执行时会产生一个轻量级的全套OS。每一个APP自带OS，是被正确部署了作为整个发布包的,运行时可以展开为设计好的全面运行环境，而无须host上的此类信息,app直接在这个guest上shell programmly运行。这就需要涉及到egxbox，在极小粒度上整合容器和语言的思想。这是后话。

2，它有组件系统

demos as engine,它也是可以被开发的。
类busybox，一堆exe像busybox中的子体一样，一个接口就是一个可运行件中的某个小运行件，在文件系统中，它是一个可以cd进.ls显示的文件系统。或许与常规fs不同的是，它会是一个executiable archive。是运行件也是开发件。任何GUI程序将基于CUI之上，CUI都是接口。

3，它是一种天然的分布式

由于开发件与运行件天然对应。且基于OS级，为了模拟类本地的host/host程序交互，需要sync2个远程guest OS来处理程序的内外上下文逻辑。如果二端的可以sync同样的结果。包括API。那么它就是一种天然的分布式和云开发的基础。所有的分布式，就成了二个OS间的通讯，而不是程序级的。因此分布式服务就能基于虚拟API进行。这是一种同步，当然也可以进行数据内容的sync，5G下这很现实，就像物联网基于container的应用发布一样，每天会产生几G的数据。

4，它有全面的开发支持，低入阶属性

由于它是纯粹的exe调用bat，将开发局限在具体app级又自带OS。因此可以在host端作为模拟器guest container实时播放。方便调试和再开发学习。playable类packer语言。demo playable类似按键精灵脚本，又类似editor的效果。对初学者入阶简单。

开发不仅是编码件，而且是调试件，这是一种良好的预埋debug middleware件设件，与带问题域统一学习支持的四合一开发方案。

———————

关注我。


-----


(此处不设回复，扫码到微信参与留言，或直接点击到原文)

![](/p/106344717/qrcode.png)

<!-- Markdeep: -->
<meta charset="utf-8">
<link rel="stylesheet" href="../../res/aloha.css?">

<script src="../../res/markdeep.min.js" charset="utf-8"></script>





