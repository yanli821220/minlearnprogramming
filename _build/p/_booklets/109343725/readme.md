---
layout: page
include_in_header: false
permalink: /_booklets/109343725/
---
一种最小(限制规模)语言kernel配合极简（无语法）扩展系统的开发
=====

__本文关键字：可裁剪语言。better c only rust, easier scripting programming,Easy ori programming,非专业编程__

在《terra++ - 一种中心稳定，可扩展的devops可编程语言系统》《terracling前端metalangsys后端uniform backend免编程binding生成式语言系统设想》《利用terralang实现terrapp(1):深刻理解其工作原理和方法论》中我们讲到对语言核心和扩展进行可裁剪的特性（类linux kernel），这种设计在app和kernel都存在，却没被用在语言设计上，。这种需求很明显，是因为现在围绕语言为中心作为代表的各种开发生态已经十分破碎，又变动频繁断层横生，提高了人们学习它们的曲线（而语言决定开发，不可能要求所有的程序员订立契约，倾向使用某种语言的统一良好特性，一门语言好的坏的都会被继承下来，又没有一种真正可裁剪的语言存在个人不可能进行改良），。一些整合现有语言类的统一后端多前端语言(c#,jvm languages)又做不到真正的前后或后端统一解决多语言带来的痛点。而一些更为新潮的语言希望彻底更新这类弊端，所以直接发明新语言，这类语言往往基于强化C简化CPP的目的出现。如go/rust/dlang。却也有新的问题产生，见《编程语言选型之技法融合，与领域融合的那些套路》。而terralang这类可裁剪的语言，可以避免二者带来的问题。

> 有一种事实已不可否认，我们的开发中涉及到多种语言，这些语言中，至少会有二种核心必要的类型：一种业务逻辑相关的（这种专业度高往往是系统编程类），一种是胶水脚本的（脚本类），当然一种语言也可以同时担负这二种职责，只是语言的这二种职责导致的复杂度界限很明显，一种可以无限复杂，一种可以无限简单，这种界限很容易被人们发觉，只是人们往往倾向滥用一门语言的设计。

go/rust/dlang
-----

人们可能滥用一门语言的设计的例子有：

比如go，是对C简化而不是C++，它倔强地不加入任何多的东西。因为它面向制造一种for网络和分布式的新c规范（类lua的协程和轻运行时促成的分布式，lua的语法体量也极小和stable，我怀疑go当初基本就是它是一个翻创），它深深意识到，c成功的主要因素除了它是构建基本所有现代OS的基石（windows,linux,osx），还因为它本身保持了一个极小的标准，而几十年不变。即使这是一门专业人员使用的平台逻辑/系统编程类/业务类语言，也应该是为了简单而存在的（脚本类非业务逻辑其实也应该简单化）。应该将扩展放置在其它的合适的层次。----- go在这点上控制的确不错：只要它不将其它的特点加入语言核心，人们就不可能会滥用go本身。但是当go用户需要更强大的抽象时就只能寻求库级方案。

然后rust，是对c的增强对cpp的简化，它聪明地为c增加了内存安全和并发安全的特点，但是它没有像go一样考虑到以上特性，正在考虑将泛型这样的东西加入语言核心。关于语言功能是选择核心化还是选择库化是关乎语言设计生命的，放进语言核心可以使语言更一致地处理编程范式，但代价和另外一个问题是使得语言复杂化和臃肿化。

> 导致这一现象出现的根本是因为，即使在系统实现和业务逻辑层，语言也需要高阶抽象和工程设计支持来获得对开发的支持。而这是另外的职责层面 ----- 脚本和用户逻辑所在。而rust中没有显式的分开控制。这很危险，当rust那些现在看起来适合整合的特性在10年之后变得不那么合理了，它可能会变成另外一种 cpp。所以我们要规避使用这个职责部分，以下会说到。

d语言似乎比这二者都要好一点，因为它在设计中，加入了很多显式的范式规范，如betterc开关，gc开关，而它又是一种二进制与 C、C++ 兼容的c family语言，这使得它在实际上就是一种“二种职责分离了的语言”。

对于新手入阶的方案：
-----

以上这些理论成为语言需要良好的可裁剪特性出现的重要论据。具体到现实做法上，首先是将一门语言负责编写核心业务的部分和用来给非专业用户使用的部分分不开，不让使用这门语言的人进行滥用。

> 语言的专业度和向简性是一对实实在在存在的矛盾，系统编程是任何编程开始的地方要求所用语言严密，用户编程可以使用非安全代码和动态类型追求简易和效率。如何将这二种需求融合在一门语言中，最重要的手段还是提供明确区分二者界限的方式。terralang这种就有支持,比如它继续了lua对外来类型就是user data type定义的属性，而语法扩展层面，则可以通过函数式元编程继续。

对于新手的学习，这种分离可以让人们迅速入阶，视各种新语言为仅拥有不同kernel（各种方言c）。但脚本层统一新的语言体系。大大降低学习成本。甚至可将所有语言的kernel植进一个新的统一 clr。

对于terralang这样的天生设计成支持裁剪的语言，我们只需各自使用好c,lua的原来部分即可(lua,c定义了二种极简正交的语言系统kernels对应上面说到的二种职责，而terra允许混用它们组成整个混合kernel)。语言的扩展全部实现为模块。因为它内置clang kernel可利用terralang实现基于大量c的方言系统。terralang是一种c的代替，类似go对c做的工作，它对c采用的简化方向是使其接近lua(luajit ffi本来就有极好的与c交互，terra进一步发展了这层交互不引入新的复杂性)，为什么是lua，因为它是一种类似bash的ultra simple语言。

对于rust这种，我们要时刻把它当成一门拥有最小“不可变核心”的语言+扩展构成的体系，平时大量使用其基础类型系统和过程结构，视它是一种“betterc only rust”，在寻求可复用和工程支持时，应该将rust的这些高层抽象语言用其它的语言代替（如python这种胶水语言，甚至bash这种不像严肃语言的语言，对用户来说其实更合适，见《一种云化busybox demolets的设想：免部署无语法编程》,它实际上是变通用编程为问题绑定的编程。而且尽力去掉语法，这是为入阶人士量身打造的实训环境）。能不用则不用。


-------


(此处不设回复，扫码到微信参与留言，或直接点击到原文)

![](/p/109343725/qrcode.png)

<!-- Markdeep: -->
<meta charset="utf-8">
<link rel="stylesheet" href="../../res/aloha.css?">

<script src="../../res/markdeep.min.js" charset="utf-8"></script>

